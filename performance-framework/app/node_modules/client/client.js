var request = require('request');
var util = require('util');
var zlib = require('zlib');
var httpreq = require('http').request;
var querystring = require('querystring');

var Client = function () {
    this.fn = null;
    this.actions = [];
    this.fns = [];
    this.breathIntervalTime = 200;
    this.sendInterval = 8;
    this.responseTimeOut = 30000
};

module.exports = Client;

Client.prototype.run = function () {

    var self = this;
    var timer = setInterval(breath, self.breathIntervalTime);

    function breath() {

        if (self.fn === null) {
            self.fn = self.actions.shift();
            return
        }
        if (self.fn() === undefined) {
            if (self.actions.length) {
                self.fn = self.actions.shift();
            } else {
                self.log('debug', 'Clear timer' + self.fns.length)
                clearInterval(timer);
            }
        }
    }
};

Client.prototype.randomIntTime = function (low, high) {
    var _low = low || this.sendInterval * 500;
    var _high = high || this.sendInterval * 1500;
    return Math.floor(Math.random() * (_high - _low + 1) + _low);
};

Client.prototype.init = function (params, cb) {
    this.port = params.port;
    this.host = params.host;
    this.caseData = params.caseData;
    this.headers = params.headers;
    this.agent = params.agent || false;
    setImmediate(cb);
};

Client.prototype.getCurrentTime = function () {
    var self = this;
    var cTime = new Date().toLocaleString().split(' ').slice(0, 5).join(' ');
    return self.stylize(cTime, 'green');
};

Client.prototype.stylize = function (str, style) {
    var styles = {
        'bold': [1, 22],
        'italic': [3, 23],
        'underline': [4, 24],
        'cyan': [96, 39],
        'blue': [34, 39],
        'yellow': [33, 39],
        'green': [32, 39],
        'red': [31, 39],
        'grey': [90, 39],
        'green-hi': [92, 32]
    };
    return '\033[' + styles[style][0] + 'm' + str +
        '\033[' + styles[style][1] + 'm';
};

Client.prototype.log = function (level, msg) {
    var self = this;
    if (self.caseData.debug && level.toLowerCase() !== 'error') {
        console.log('[%s] %s : %s', self.getCurrentTime(), self.stylize(level.toUpperCase(), 'green'), msg);
    } else {
        if (level.toLowerCase() == 'error') {
            console.log('[%s] %s : %s', self.getCurrentTime(), self.stylize('ERROR', 'red'), self.stylize(msg, 'red'));
        }
    }
};

Client.prototype.parseBuffer = function (buffer, encoding) {
    var encoding = encoding || 'json';
    var data = '';
    switch (encoding) {
        case 'json':
            data = JSON.parse(buffer);
            break;
        case 'gzip':
            zlib.gunzip(buffer, function (err, decoded) {
                data = decoded && decoded.toString();
            });
            break;
        case 'deflate':
            zlib.inflate(buffer, function (err, decoded) {
                data = decoded && decoded.toString()
            });
            break;
        default:
            data = buffer.toString();
    }
    return data;
};

Client.prototype.request = function (opts, cb) {
    var self = this;

    if (!!body) {
        //self.reqstr = querystring.stringify(body, '%26', '%3d');
        self.reqstr = querystring.stringify(body);
        path += self.reqstr;

    }

    var options = {
        hostname: self.host,
        port: self.port,
        method: opts.method,
        path: '/' + path,
        agent: self.agent,
        headers: self.headers
    };

    var req = httpreq(options, function (res) {
        res.setEncoding('utf8');
        var iMsg = '';
        res.on('data', function (chunk) {
            iMsg += chunk;
        });
        res.on('end', function () {
            data = JSON.parse(iMsg);
            if (/errmsg/i.test(iMsg)) {
                self.log('error', iMsg);
            } else {
                self.log('debug', iMsg);
                cb(res.statusCode, data);
            }
        });
    });

    req.setTimeout(self.responseTimeOut, function () {
        self.log('error', 'Request time out!');
        self.log('error', 'Sending data ' + options.hostname + ':' + options.port + options.path);
        req.abort();
    });
    req.on('error', function (e) {
        self.log('error', e.toString());
        self.log('debug', 'Sending data ' + options.hostname + ':' + options.port + options.path);
        cb(e);
    });
    self.log('debug', 'Sending data ' + options.hostname + ':' + options.port + options.path);
    req.end();
};
