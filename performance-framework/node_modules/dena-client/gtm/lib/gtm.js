/**
 * Created by Administrator on 2015/4/24.
 */

/**
 * protocol for gtm
 */

var ByteBuffer = require('dena-bytebuffer');

var Protocol = {}

Protocol.encode = function (EProtoId, EProtoBody) {
    var byteLength = EProtoBody === undefined ? 0 : EProtoBody.length;
    var byteBuffer = new ByteBuffer(); // С��

    byteBuffer.ushort(EProtoId);
    byteBuffer.byte(0);
    byteBuffer.byte(0);
    byteBuffer.ushort(byteLength);

    if (byteLength) {
        byteBuffer.byteArray(EProtoBody, byteLength);
    }

    return byteBuffer.pack();
}

Protocol.decode = function (msg) {
    var package = {'EProtoLen': 0, 'EProtoId': 0, 'EProtoBody': null};
    var byteBuffer = new ByteBuffer(msg); // С��

    if (msg.length === 6) {
        var unpackArray = byteBuffer.ushort().byte().byte().ushort().unpack();
        package.EProtoId = unpackArray.shift();
        package.EProtoLen = unpackArray.pop();
        package.EProtoBody = new Buffer(0);
    } else if (msg.length > 6) {
        var unpackArray = byteBuffer.ushort().byte().byte().ushort().byteArray(null, msg.length - 6).unpack();
        package.EProtoId = unpackArray.shift();
        package.EProtoBody = new Buffer(unpackArray.pop());
        package.EProtoLen = unpackArray.pop();
    } else {
        throw new Error('Unexpected msg Length!');
    }

    return package
}

var net = require('net');

var Gtm = function () {
    this.socket = null;
    this.fn = null;

    this.dataChunks = [];
    this.actions = [];
    this.packageList = [];
    this.callbacks = {};
    this.customValue = {};
    this.caseData = {
        previous: false,
        debug: 1,
        ratemode: 1
    };
    this.breathIntervalTime = 100;
    this.responseOverTime = 5000;
    this.sendInterval = 6;
};

module.exports = Gtm;

Gtm.prototype.run = function () {
    var self = this;

    var timer = setInterval(breath, self.breathIntervalTime);

    function breath() {

        if (self.fn === null) {
            self.fn = self.actions.shift();
            return
        }

        if (self.fn() === undefined) {
            if (self.actions.length) {
                self.fn = self.actions.shift();
            } else {
                console.log('clear timer')
                clearInterval(timer);
            }
        }
    }
};

Gtm.prototype.randomIntTime = function (low, high) {
    var sendInterval = this.sendInterval || 6;
    var low = low || sendInterval * 500;
    var high = high || sendInterval * 1500;
    return Math.floor(Math.random() * (high - low + 1) + low);
}

Gtm.prototype.connect = function (params, cb) {

    var port = params.port;
    var host = params.host;

    if (this.caseData.debug) {
        console.log('[%s] %s: %s %s:%s', new Date().toLocaleTimeString(), 'INFO', 'Connecting to:', host, port);
    }

    this.socket = net.connect(port, host);

    var self = this;
    this.socket.on('connect', function () {
        cb();
    });

    this.socket.on('data', function (data) {
        self.dataChunks.push(data);
        processMessage(self);
        processPackage(self);
    });

    this.socket.on('error', function (error) {
        console.log('[gtmclient.socket.error] tcp-socket code: %s!', error.code);
    });

    this.socket.on('close', function (result) {
        console.log('[gtmclient.socket.close] tcp-socket closeed!');
    })
}

Gtm.prototype.register = function (EProtoId, cb) {
    if (EProtoId === undefined || cb == undefined)
        return;

    this.callbacks[EProtoId] = cb;
}

Gtm.prototype.unregister = function (EProtoId) {
    this.callbacks[EProtoId] = undefined;
}

Gtm.prototype.request = function (EProtoId, EProtoBody) {

    if (EProtoId === undefined)
        return;

    var args = Array.prototype.slice.apply(arguments);
    if (args.length == 4) {
        this.callbacks[args[2]] = args[3];
    }
    var sg = Protocol.encode(EProtoId, EProtoBody);
    if (this.caseData.debug) {
        //console.log('[%s] %s: %s [ %s ] ', new Date().toLocaleTimeString(), 'INFO', 'Sending  EProtoId====>:', EProtoId.toString(16).toUpperCase());
        //console.log('[%s] %s: %s [ %s ] ', new Date().toLocaleTimeString(), 'INFO', 'Sending  EProtoBody====>:', EProtoBody);
        console.log('[%s] %s: %s [ %s ] ', new Date().toLocaleTimeString(), 'INFO', 'Sending  sg====>:', sg);
    }
    console.log('[%s] %s: %s [ %s ] ', new Date().toLocaleTimeString(), 'INFO', 'Sending  sg====>:', sg.length);
    this.socket.write(sg);
};

Gtm.prototype.close = function () {
    if (this.socket) {
        console.log('tcp-socket disconnect!');
        this.socket.destroy();
        this.socket = null;
    }
};

var processMessage = function (self) {
    var buf = Buffer.concat(self.dataChunks);
    var len = buf.length;
    if (len >= 6) {
        var package = Protocol.decode(buf.slice(0, 6));
        if (len >= package.EProtoLen + 6) {
            self.packageList.push(buf.slice(0, package.EProtoLen + 6));
            self.dataChunks = [buf.slice(package.EProtoLen + 6, len)];
            processMessage(self);
        }
    }
};

var processPackage = function (self) {
    if (self.caseData.debug) {
        console.log('[INFO] %s: Received self.packageList====>:%s', new Date().toLocaleTimeString(), self.packageList.length);
    }
    while (self.packageList.length) {
        var msg = self.packageList.shift();
        var package = Protocol.decode(msg);
        var cb = self.callbacks[package.EProtoId];
        if (self.caseData.debug) {
            //console.log('[%s] %s: Received EProtoBody====> : [ %s ]', new Date().toLocaleTimeString(), 'INFO', package.EProtoBody.toString());
            console.log('[INFO] %s: Received EProtoId====>:%s', new Date().toLocaleTimeString(), package.EProtoId.toString(16).toUpperCase());
        }
        if (cb) {
            cb(package.EProtoBody);
        }
    }
};
