/**
 * Created by yong.liu on 2015/5/7.
 */

/**
 * bleach client
 */

var zlib = require('zlib');
var request = require('request');
var querystring = require('querystring');

var Tff = function () {
    this.fn = null;
    this.actions = [];
    this.customValue = {};

    this.breathIntervalTime = 100; // ��λ : ����
    this.responseOverTime = 5000; // ��λ : ����
    this.thinkTime = [3000, 5000]; // ���˼��ʱ�� ��λ : ����
};

module.exports = Tff;

Tff.prototype.run = function () {
    var self = this;

    var timer = setInterval(breath, self.breathIntervalTime);

    function breath() {
        if (self.fn === null) {
            self.fn = self.actions.shift();
            return
        }

        if (self.fn() === undefined) {
            if (self.actions.length) {
                self.fn = self.actions.shift();
            } else {
                console.log('clear timer')
                clearInterval(timer);
            }
        }
    }
};

Tff.prototype.getThinkTime = function () {
    var min = this.thinkTime[0];
    var max = this.thinkTime[1];

    return Math.floor(Math.random() * (max - min + 1)) + min;
}

Tff.prototype.init = function (params, cb) {
    this.port = params.port;
    this.host = params.host;

    this.options = {
        headers: {
            'Accept-Encoding': 'gzip',
            'User-Agent': 'node'
        }
    };

    setImmediate(cb);
}

Tff.prototype.get = function (path, param, callback) {
    this.options.url = 'http://' + this.host + ':' + this.port + path + '?' + querystring.stringify(param);
    //console.log(this.options.url);

    var req = request.get(this.options);

    req.on('response', function (res) {
        var chunks = [];

        res.on('data', function (chunk) {
            chunks.push(chunk);
        });

        res.on('end', function () {
            var message = {};
            message.code = res.statusCode;

            var buffer = Buffer.concat(chunks);
            var encoding = res.headers['content-encoding'];

            switch (encoding) {
                case 'gzip':
                    zlib.gunzip(buffer, function (err, decoded) {
                        message.body = decoded && decoded.toString()
                        callback(message);
                    });

                    break;
                case 'deflate':
                    zlib.inflate(buffer, function (err, decoded) {
                        message.body = decoded && decoded.toString()
                        callback(message);
                    });

                    break;
                default:
                    message.body = buffer.toString()
                    callback(message);
            }
        });
    });

    req.on('error', function (err) {
        callback(err);
    });
};